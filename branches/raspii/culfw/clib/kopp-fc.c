/*  * ----------------------------------------------------------------------------------------------------------------------------------------------------* * This is my first trial to send to Kopp Free Control Units via CUL CCD Module *  * Remaining lines from former MORITZ Modul, can be deleted as soon I understand meaning :-) *    * CC1100_PKTCTRL0.LENGTH_CONFIG = 1 //Variable packet length mode. Packet length configured by the first byte after sync word                         *  *                 CRC_EN = 1                                                                                                                          * *                 PKT_FORMAT = 00 //Use FIFOs                                                                                                         * *                 WHITE_DATA = 0                                                                                                                      * * MDMCFG2.SYNC_MODE = 3: 30/32 sync word bits detected                                                                                                * *        .MANCHESTER_EN = 0                                                                                                                           * *        .MOD_FORMAT = 0: 2-FSK                                                                                                                       * *        .DEM_DCFILT_OFF = 0                                                                                                                          * *                                                                                                                                                     * * EVENT0 = 34667                                                                                                                                      * * t_Event0 = 750/26Mhz * EVENT0 * 2^(5*WOR_RES) = 1 second                                                                                            * *                                                                                                                                                     * * One message with 12 payload bytes takes (4 byte preamble + 4 byte sync + 12 byte payload) / 1kbit/s = 160 ms.                                       * *																																					   * * Date		   Who				Comment																												   * * ----------  -------------   	-----------------------------------------------------------------------------------------------------------------------* * 2014-08-01  Claus M.			first Version * *  * ----------------------------------------------------------------------------------------------------------------------------------------------------* */#ifdef HAS_KOPP_FC#include "board.h"#include <string.h>#include <avr/pgmspace.h>#include <avr/interrupt.h>#include <avr/io.h>#include "cc1100.h"#include "delay.h"#include "rf_receive.h"#include "display.h"#include "clock.h"#include "rf_send.h" //credit_10ms//#include "rf_moritz.h"#include "kopp-fc.h"#include "fncollection.h"void kopp_fc_sendraw(uint8_t* buf, int longPreamble);void kopp_fc_sendAck(uint8_t* enc);void kopp_fc_handleAutoAck(uint8_t* enc);uint8_t kopp_fc_on = 0;// Kopp Free-Control Inititalisieren// ==================================const PROGMEM const uint8_t CC1100_Kopp_CFG[EE_CC1100_CFG_SIZE] = {//  CC1101 Register Initialisation (see CC1101 Page 70ff and 62ff)//  Data   Adr  Reg.Name RESET STUDIO COMMENT// ======  ==== ======== ===== ====== =================================================================================================================================	0x07, // 00  IOCFG2   *29   *0B    GDO2_CFG=7: GDO2 Asserts when a packet has been received with CRC OK. De-asserts when the first byte is read from the RX FIFO	0x2E, // 01  IOCFG1    2E    2E    no change yet	0x46, // 02  IOCFG0   *3F   *0C    GDO0_CFG=2: Associated to the TX FIFO: Asserts when the TX FIFO is filled at or above the TX FIFO threshold. 	      //                   		   De-asserts when the TXFIFO is below the same threshold.   	0x07, // 03  FIFOTHR   07   *47	0xAA, // 04  SYNC1     D3    D3    Sync High Byte = AA (assumption: High Byte is first send sync byte)	0x54, // 05  SYNC0     91    91    Sync Low  Byte = 54 (AA 54 sollte als Sync funktinieren)	0x08, // 06  PKTLEN   *FF    3D    Package length for Kopp 8 Bytes (incl. Cks, because handled as data because no standard CC1101 checksum)	0xE0, // 07  PKTCTRL1  04    04    Preamble quality is maximum(7), No Auto RX Fifo Flush, No Status Bytes will be send, No Address check	0x00, // 08  PKTCTRL0 *45    32    Data whitening off,  Rx and Tx Fifo, CRC disabled, Fixed package length	0x00, // 09  ADDR      00    00    Device Adress (Adress filter not used)	0x00, // 0A  CHANNR    00    00    Channel Number (added to Base Frequency) is not used	0x06, // 0B  FSCTRL1  *0F    06    152,34375 kHz IF Frquency (##Claus: to be adjusted for Kopp, later if RX is used)	0x00, // 0C  FSCTRL0   00    00    Frequency Offset = 0	0x21, // 0D  FREQ2    *1E    21    FREQ[23..0] = f(carrier)/f(XOSC)*2^16  -> 868,3Mhz / 26Mhz * 2^16 = 2188650 dez = 21656A hex  (f(XOSC)=26 Mhz)	0x65, // 0E  FREQ1    *C4    65    s.o.	0x6A, // 0F  FREQ0    *EC    e8    s.o.	0x97, // 10  MDMCFG4  *8C    55    bWidth 162,5 kHz   (Kopp 50 Khz!, but does not work))	0x82, // 11  MDMCFG3  *22   *43    Drate: 4785,5 Baud   (Kopp: 4789 Baud, measured value !! may be increase by 1 is needed (83) because value should be 4800) )	0x16, // 12  MDMCFG2  *02   *B0    DC Blocking filter enabled, GFSK modulation (Kopp uses FSK, do not know whether 2-FSK, GFSK odr 4-FSK),           //                           manchester en-decoding disabled, 16 sync bits to match+carrier-sense above threshold	0x63, // 13  MDMCFG1  *22    23    Error Correction disabled, min 16 preamble bytes, Channel spacing = 350 khz	0xb9, // 14  MDMCFG0  *F8    b9    Channel spacing 350kHz  (Copied from somfy, do not know if ok ) 	0x47, // 15  DEVIATN  *47    00    frequency deviation = 47,607 khz (default, do not know if right, for RFM12b I used 45khz)	0x07, // 16  MCSM2     07    07    	0x00, // 17  MCSM1     30    30    Transmitter goes idle after finisching package transmission	0x18, // 18  MCSM0    *04    18    Calibration after IDLE->RX/TX, PO_Timeout=2	0x36, // 19  FOCCFG   *36    14	0x6C, // 1A  BSCFG     6C    6C	0x07, // 1B  AGCCTRL2 *03   *03    42 dB instead of 33dB	0x40, // 1C  AGCCTRL1 *40   *40	0x91, // 1D  AGCCTRL0 *91   *92    	0x87, // 1E  WOREVT1   87    87	0x6B, // 1F  WOREVT0   6B    6B	0xF8, // 20  WORCTRL   F8    F8	0x56, // 21  FREND1    56    56	0x16, // 22  FREND0   *16    17    	0xE9, // 23  FSCAL3   *A9    E9   as calculated by Smart RF Studio	0x2A, // 24  FSCAL2   *0A    2A   as calculated by Smart RF Studio	0x00, // 25  FSCAL1    20    00   as calculated by Smart RF Studio	0x1F, // 26  FSCAL0    0D    1F   as calculated by Smart RF Studio	0x41, // 27  RCCTRL1   41    41	0x00, // 28  RCCTRL0   00    00};// static uint8_t autoAckAddr[3] = {0, 0, 0};// static uint8_t fakeWallThermostatAddr[3] = {0, 0, 0};static uint32_t lastSendingTicks = 0;voidkopp_fc_init(void){  EIMSK &= ~_BV(CC1100_INT);                 	// disable INT - we'll poll...  SET_BIT( CC1100_CS_DDR, CC1100_CS_PIN );   	// CS as output// Toggle chip select signal (why?)  CC1100_DEASSERT;                            	// Chip Select InActiv  my_delay_us(30);  CC1100_ASSERT;								// Chip Select Activ  my_delay_us(30);  CC1100_DEASSERT;								// Chip Select InActiv  my_delay_us(45);  ccStrobe( CC1100_SRES );                   	// Send SRES command (Reset CC110x)  my_delay_us(100);// load configuration (CC1100_Kopp_CFG[EE_CC1100_CFG_SIZE])  CC1100_ASSERT;								// Chip Select Activ	 cc1100_sendbyte( 0 | CC1100_WRITE_BURST );	 for(uint8_t i = 0; i < EE_CC1100_CFG_SIZE; i++) {	 	cc1100_sendbyte(__LPM(CC1100_Kopp_CFG+i));	 } 	CC1100_DEASSERT;							// Chip Select InActiv  //  ccStrobe( CC1100_SCAL );                   	// Calibrate Synthesizer and turn it of. ##Claus brauchen wir das//  my_delay_ms(4); 							  	// 4ms: Found by trial and error  //This is ccRx() but without enabling the interrupt//  uint8_t cnt = 0xff;  //Enable RX. Perform calibration first if coming from IDLE and MCSM0.FS_AUTOCAL=1.  //Why do it multiple times?//  while(cnt-- && (ccStrobe( CC1100_SRX ) & 0x70) != 1)//    my_delay_us(10);  kopp_fc_on = 1;								//##Claus may be not needed in future (Tx Only)}//------------------ kopp_fc_init  E N D   -------------------------------------------------------------------------// ##Claus Sees *_task() is the handler for receive date (ib bit *_on =1), // do not need for sendingdata only// void// kopp_fc_task(void)// {//   uint8_t enc[MAX_kopp_fc_MSG];//   uint8_t rssi;//  // RSSI is appended to RXFIFO//     rssi = cc1100_sendbyte( 0 );// 	//     if (tx_report & REP_BINTIME) {// //       DC('z');										// DC = Display Character?//       for (uint8_t i=0; i<=enc[0]; i++)//       DC( enc[i] );//     } else {//       DC('Z');//       for (uint8_t i=0; i<=enc[0]; i++)	//         DH2( enc[i] );								// DH2 = Display Hex 2 ?//       if (tx_report & REP_RSSI)//         DH2(rssi);//       DNL();//     }// //     return;//   }// If Rx Buffer Overflow //  if(cc1100_readReg( CC1100_MARCSTATE ) == 17) //  {//    ccStrobe( CC1100_SFRX  );						// Flush (empty)  Rx buffer//    ccStrobe( CC1100_SIDLE );						// Exit RX/TX, turn off synthesizer and exit Wake-On-Radio mode if applicable//    ccStrobe( CC1100_SRX   );						// Enable RX, Perform claibration first if comming from IDLE and MCSM0.FS_AUTOCAL=1//  }// }// void// kopp_fc_send(char *in)//{  /* we are not affected by CC1101 errata #6, because MDMCFG2.SYNC_MODE != 0 (we have preamble and snyc)*///  uint8_t dec[MAX_kopp_fc_MSG];//  uint8_t hblen = fromhex(in+1, dec, MAX_kopp_fc_MSG-1);//  if ((hblen-1) != dec[0]) {//    DS_P(PSTR("LENERR\r\n"));//    return;//  }//  kopp_fc_sendraw(dec, 1);// }/* longPreamble is necessary for unsolicited messages to wakeup the receiver */voidkopp_fc_sendraw(uint8_t *dec, int longPreamble){  uint8_t hblen = dec[0]+1;  //1kb/s = 1 bit/ms. we send 1 sec preamble + hblen*8 bits  uint32_t sum = (longPreamble ? 100 : 0) + (hblen*8)/10;  if (credit_10ms < sum) {    DS_P(PSTR("LOVF\r\n"));    return;  }  credit_10ms -= sum;// in Moritz mode already?//  if(!kopp_fc_on) {//  kopp_fc_init();//  }//  if(cc1100_readReg( CC1100_MARCSTATE ) != MARCSTATE_RX) // { //error//    DC('Z');//    DC('E');//    DC('R');//    DC('R');//    DC('1');//    DH2(cc1100_readReg( CC1100_MARCSTATE ));//    DNL();//    kopp_fc_init();//    return;//  }  /* We have to keep at least 20 ms of silence between two sends   * (found out by trial and error). ticks runs at 125 Hz (8 ms per tick),   * so we wait for 3 ticks.   * This looks a bit cumbersome but handles overflows of ticks gracefully.   */  if(lastSendingTicks)    while(ticks == lastSendingTicks || ticks == lastSendingTicks+1)      my_delay_ms(1);  /* Enable TX. Perform calibration first if MCSM0.FS_AUTOCAL=1 (this is the case) (takes 809μs)   * start sending - CC1101 will send preamble continuously until TXFIFO is filled.   * The preamble will wake up devices. See http://e2e.ti.com/support/low_power_rf/f/156/t/142864.aspx   * It will not go into TX mode instantly if channel is not clear (see CCA_MODE), thus ccTX tries multiple times */  ccTX();  if(cc1100_readReg( CC1100_MARCSTATE ) != MARCSTATE_TX) { 	//error    DC('Z');    DC('E');    DC('R');    DC('R');    DC('2');    DH2(cc1100_readReg( CC1100_MARCSTATE ));    DNL();    kopp_fc_init();    return;  }  if(longPreamble) {    /* Send preamble for 1 sec. Keep in mind that waiting for too long may trigger the watchdog (2 seconds on CUL) */    for(int i=0;i<10;++i)      my_delay_ms(100); 										//arg is uint_8, so loop  }  // send  CC1100_ASSERT;												// Chip Select Activ  cc1100_sendbyte(CC1100_WRITE_BURST | CC1100_TXFIFO);  for(uint8_t i = 0; i < hblen; i++) {    cc1100_sendbyte(dec[i]);  }// CC1100_DEASSERT;												// Chip Select InActiv  //Wait for sending to finish (CC1101 will go to RX state automatically  //after sending  uint8_t i;  for(i=0; i< 200;++i) {    if( cc1100_readReg( CC1100_MARCSTATE ) == MARCSTATE_RX)      break; //now in RX, good    if( cc1100_readReg( CC1100_MARCSTATE ) != MARCSTATE_TX)      break; //neither in RX nor TX, probably some error    my_delay_ms(1);  }  if(cc1100_readReg( CC1100_MARCSTATE ) != MARCSTATE_RX) { //error    DC('Z');    DC('E');    DC('R');    DC('R');    DC('3');    DH2(cc1100_readReg( CC1100_MARCSTATE ));    DNL();    kopp_fc_init();  }  if(!kopp_fc_on) {    set_txrestore();  }  lastSendingTicks = ticks;}// void// kopp_fc_sendAck(uint8_t* enc)// {//  uint8_t ackPacket[12];//  ackPacket[0] = 11; /* len*///  ackPacket[1] = enc[1]; /* msgcnt *///  ackPacket[2] = 0; /* flag *///  ackPacket[3] = 2; /* type = Ack *///  for(int i=0;i<3;++i) /* src = enc_dst*///    ackPacket[4+i] = enc[7+i];//  for(int i=0;i<3;++i) /* dst = enc_src *///    ackPacket[7+i] = enc[4+i];//  ackPacket[10] = 0; /* groupid *///  ackPacket[11] = 0; /* payload */////  my_delay_ms(20); /* by experiments *///  kopp_fc_sendraw(ackPacket, 0);  //Inform FHEM that we send an autoack//  DC('Z');//  for (uint8_t i=0; i < ackPacket[0]+1; i++)//    DH2( ackPacket[i] );//  if (tx_report & REP_RSSI)//    DH2( 0 ); //fake some rssi//  DNL();//}// Kopp Free-Control Maint task (at least my assumtion it is :-) )// ================================================================voidkopp_fc_func(char *in){// If parameter 2 = "t" then  "Transmitt Free Control Telegram"  if(in[1] == 't')   {         											// Transmitt Block   DS_P(PSTR("Transmitt\r\n"));   kopp_fc_init();//	int fd;	fd = open(device, O_RDWR);	if (fd < 0)      pabort("can't open device");// Command Line Argument 1 (Hex Char) for "Block Transmitt Code" (uint8_t)// -----------------------------------------------------------------------          // uint8_t blkTXcode;                                                                    //// blkTXcode = (uint8_t) strtol(argv[1],NULL,0);                                         // Int wird hier automatisch nach uint8_t convertiert (literatur)                                                                                      ////#ifdef PrintOn  // Print Befehle müssen für CCD vermutlich angepasst werden                                                                        ////printf("Kommandozeilenargument 1: %d\n",blkTXcode);                                   ////#endif                                                                                //// Command Line Argument 2 (Unsingned Integer) to "Time till Key off [µsec)" (uint)// -------------------------------------------------------------------------------- // uint KeyOffTime;                                                                      //// KeyOffTime = (uint) strtol(argv[2],NULL,0);                                           // Int wird hier automatisch nach uint8_t convertiert (literatur)                                                                                      //// #ifdef PrintOn                                                                        //// printf("Kommandozeilenargument 2: %u\n",KeyOffTime);                                   //// #endif                                                                                //                                                                                      //// Test Timer Größe (Ergebnis: 32 Bit, zählt bis 4294967295, danach Überlauf auf 0)//   do {                                                                         // //   BlockStartTime=TIMER_ARM_COUNT;//   printf("Aktuelle Zeit:  %u\n",BlockStartTime);//   } while(TIMER_ARM_COUNT >= (BlockStartTime));                     // wait till Key Off time is gone////   printf("Aktuelle Zeit:  %u\n",TIMER_ARM_COUNT);//   printf("Aktuelle Zeit - Blockstartzeit:  %u\n",TIMER_ARM_COUNT-BlockStartTime);//do {//} while (1);// Botschaftfür kurzen Tastendruck aufbauen//-----------------------------------------// Kurzer Tastendruck, kleiner Handsender, Taste 1uint8_t DefaultKoppMessage[35] = {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x54, 0x7, 0xc8, 0xf9, 0x6e, 0x30, 0xcc, 0xf, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};//                                |--------------------------------------- Präambel 17 x AA ------------------------------------------|Header|lgth|TrmitterCode|Cnt|KeyNo|----unknown----|CkSum|----------6x00--------------|// Byte:                            0     1     2     3     4     5     6     7     8     9     10    11    12    13    14   15    16    17    18    19    20    21    22    23   24   25   26   27   28   29   30   31   32// Langer Tastendruck, kleiner Handsender, Taste 1// uint8_t DefaultKoppMessage [35] = {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x54, 0x7, 0xc8, 0xf9, 0x6e, 0xb0, 0xcc, 0xf, 0x1, 0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0};//                                    |--------------------------------------- Präambel 17 x AA ------------------------------------------|Header|lgth|TrmitterCode|Cnt|KeyNo|----unknown----|CkSum|----------6x00--------------|// Byte:                                0     1     2     3     4     5     6     7     8     9     10    11    12    13    14   15    16    17    18    19    20    21    22    23   24   25   26   27   28   29   30   31   32// send the whole data block                                                                                         // --------------------------void TransmittKoppBlk(uint8_t[], uint8_t);TransmittKoppBlk(DefaultKoppMessage, blkTXcode);// If TX Code was >=0x80 -> Long Key preasure, now send 2x Key off// ------------------------------------------------------------if (blkTXcode >= 0x80) {                                                        // blkTXcode = 0xf7;                                                               // Key Off Code   do {                                                                         //    } while(((TIMER_ARM_COUNT-BlockStartTime)&0xffffffff) <= KeyOffTime);        // wait till Key Off time is gone  (0xfff.... to compensate timer overflow / negative values, not sure wheter needed)   TransmittKoppBlk(DefaultKoppMessage, blkTXcode);                             // Send 1st Key Off Block    do {                                                                         //    } while(((TIMER_ARM_COUNT-BlockStartTime)&0xffffffff) <= 160275);            // wait for 160,275 ms    (as measured with receiver)   TransmittKoppBlk(DefaultKoppMessage, blkTXcode);                             // Send 2nd Key Off Block     }// printf("Done\n");// Currenty unreachable   close(fd);//   return 0 					##Claus not needed for CCD, because not a subroutine here// Main Ende !!!!! (to be clarified whether code below needed//--------------------------------------------------------------------------------------------------------------------------------------//####Claus neuer Code von Moritz, ggf. noch anpassen									// initialize CC110x       uint8_t dec[MAX_kopp_fc_MSG];//     uint8_t hblen = fromhex(in+2, dec, MAX_kopp_fc_MSG-1);//     if ((hblen-1) != dec[0]) //	    {//       DS_P(PSTR("LENERR\r\n"));//       return;//      }     kopp_fc_sendraw(dec, in[1] == 's');  //##Claus ??????   }    else 											// Sub Command <> "t"   {                          // Off     DS_P(PSTR("Kopp SubCommand Unknown\r\n"));     kopp_fc_on = 0;   }}#endif